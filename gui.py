import tkinter as tk
from tkinter import ttk, messagebox
import yaml
import os

CONFIG_FILE = 'config.yaml'

# --- Define parameters with limited options ---
# Keys here should match keys in your config.yaml
# For booleans, use [True, False]
# For other enums, provide a list of allowed values (can be str, int, float)
PARAMETER_OPTIONS = {
    'verbose': [True, False],
    'save_media': [True, False],
    'output_on_file': [True, False],
    'input_type': ['video', 'image'],
    'region_type': ['vertical_line', 'rectangle'],
}


# --- Configuration Handling (mostly unchanged) ---
def load_config(file_path):
    if not os.path.exists(file_path):
        return None
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            config = yaml.safe_load(f)
        if config is None:
            return {}
        return config
    except yaml.YAMLError as e:
        messagebox.showerror("YAML Error", f"Error parsing YAML file '{file_path}':\n{e}")
        return None
    except Exception as e:
        messagebox.showerror("Load Error", f"Failed to load config from '{file_path}':\n{e}")
        return None


def save_config(file_path, data):
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            yaml.dump(data, f, default_flow_style=False, sort_keys=False)
        messagebox.showinfo("Success", f"Configuration saved successfully to '{file_path}'!")
    except Exception as e:
        messagebox.showerror("Save Error", f"Failed to save config to '{file_path}':\n{e}")


# --- GUI Application ---
class ConfigEditorApp:
    def __init__(self, root_window):
        self.root = root_window
        self.root.title("YAML Configuration Editor V2")
        self.initialized_properly = False
        self.config_data = None
        self.entries = {}

        if not os.path.exists(CONFIG_FILE):
            if messagebox.askyesno(title="Configuration Missing",
                                   message="'{CONFIG_FILE}' not found.\nWould you like to create a "
                                   f"default one (see console for sample)?"):
                # Default config generated by __main__ if this script is run directly.
                # Here, we'll just create a minimal one if the user agrees.
                self.config_data = {
                    'robot_name': 'MyConfigurableRobot',
                    'version': '0.2.0',
                    'debug_output_enabled': True,  # For Radiobutton
                    'log_level': 'INFO',  # For Combobox
                    'operating_frequency_hz': 50  # For Combobox (numeric)
                }
                save_config(CONFIG_FILE, self.config_data)
            else:
                messagebox.showinfo("Info", "Application will close as no config is available.")
                self.root.destroy()
                return

        if self.config_data is None:
            self.config_data = load_config(CONFIG_FILE)

        if self.config_data is None:
            if os.path.exists(CONFIG_FILE):
                messagebox.showerror("Error", f"Failed to load '{CONFIG_FILE}'. Check messages or file.")
            self.root.destroy()
            return

        self.create_widgets()
        self.initialized_properly = True

    def create_widgets(self):
        for widget in self.root.winfo_children():
            widget.destroy()
        self.entries.clear()

        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)

        canvas = tk.Canvas(main_frame)
        scrollbar = ttk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")
        main_frame.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)

        row_idx = 0
        if not self.config_data:
            ttk.Label(scrollable_frame, text="No configuration parameters found or config is empty.") \
                .grid(row=row_idx, column=0, columnspan=2, pady=10, padx=5, sticky=tk.W)
        else:
            for key, value in self.config_data.items():
                ttk.Label(scrollable_frame, text=f"{key}:").grid(row=row_idx, column=0, sticky=tk.W, padx=5, pady=3)

                if key in PARAMETER_OPTIONS:
                    options = PARAMETER_OPTIONS[key]
                    current_value = value

                    if options == [True, False] or options == [False, True]:  # Boolean Radiobuttons
                        bool_var = tk.BooleanVar(value=bool(current_value))  # Ensure boolean value
                        self.entries[key] = bool_var
                        rb_frame = ttk.Frame(scrollable_frame)
                        ttk.Radiobutton(rb_frame, text="True", variable=bool_var, value=True).pack(side=tk.LEFT, padx=2)
                        ttk.Radiobutton(rb_frame, text="False", variable=bool_var, value=False).pack(side=tk.LEFT,
                                                                                                     padx=2)
                        rb_frame.grid(row=row_idx, column=1, sticky=tk.W, padx=5, pady=3)
                    else:  # Combobox for other enumerable options
                        combo_var = tk.StringVar()
                        self.entries[key] = (combo_var, options)  # Store var and original options

                        display_options = [str(opt) for opt in options]
                        combobox = ttk.Combobox(scrollable_frame, textvariable=combo_var, values=display_options,
                                                state="readonly", width=47)

                        str_current_value = str(current_value)
                        if str_current_value in display_options:
                            combobox.set(str_current_value)
                        elif display_options:  # Default to first option if current value is not in the list
                            combobox.set(display_options[0])

                        combobox.grid(row=row_idx, column=1, sticky=tk.EW, padx=5, pady=3)
                elif isinstance(value, (dict, list)):  # Complex types (read-only text area)
                    display_val = yaml.dump(value, indent=2, sort_keys=False).strip()
                    text_area = tk.Text(scrollable_frame, height=min(5, display_val.count('\n') + 2), width=50,
                                        wrap=tk.WORD)
                    text_area.insert(tk.END, display_val)
                    text_area.config(state=tk.DISABLED, background=self.root.cget('bg'))
                    text_area.grid(row=row_idx, column=1, sticky=tk.EW, padx=5, pady=3)
                    self.entries[key] = value  # Store original complex value
                else:  # Standard Entry for simple types not in PARAMETER_OPTIONS
                    entry_var = tk.StringVar(value=str(value if value is not None else ""))
                    entry = ttk.Entry(scrollable_frame, textvariable=entry_var, width=50)
                    entry.grid(row=row_idx, column=1, sticky=tk.EW, padx=5, pady=3)
                    self.entries[key] = entry_var
                row_idx += 1

        scrollable_frame.columnconfigure(1, weight=1)

        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=1, column=0, columnspan=2, pady=10, sticky=tk.E)
        ttk.Button(button_frame, text="Save Changes", command=self.save_changes).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Reload Config", command=self.reload_config_ui).pack(side=tk.LEFT, padx=5)

    def save_changes(self):
        if self.config_data is None:
            messagebox.showerror("Error", "No configuration loaded.")
            return

        updated_config = self.config_data.copy()

        for key, stored_item in self.entries.items():
            original_value_in_config = self.config_data.get(key)

            if isinstance(stored_item, tk.BooleanVar):  # Radio buttons for boolean
                updated_config[key] = stored_item.get()
            elif isinstance(stored_item, tuple) and \
                    isinstance(stored_item[0], tk.StringVar) and \
                    isinstance(stored_item[1], list):  # Combobox (var, original_options)

                combo_var, original_options = stored_item
                selected_str_value = combo_var.get()

                value_found_in_options = False
                for opt in original_options:  # Find the original typed value
                    if str(opt) == selected_str_value:
                        updated_config[key] = opt
                        value_found_in_options = True
                        break
                if not value_found_in_options:
                    # This case should ideally not be reached if combobox is readonly and populated correctly.
                    # Fallback: store the string value or try a sensible conversion.
                    # For robustness, could try to cast selected_str_value based on type of original_options[0]
                    messagebox.showwarning(title="Save Warning",
                                           message="Value '{selected_str_value}' for '{key}' was not in predefined"
                                                   " options. Saving as string or first option type if possible.")
                    # As a simple fallback, we'll just use the string. More sophisticated handling could be added.
                    updated_config[key] = selected_str_value

            elif isinstance(stored_item, tk.StringVar):  # Standard Entry field
                new_value_str = stored_item.get()
                try:
                    if new_value_str == "" and not isinstance(original_value_in_config, str):
                        updated_config[key] = None
                    elif isinstance(original_value_in_config, bool):  # Should be handled by BooleanVar, but as fallback
                        if new_value_str.lower() == 'true':
                            updated_config[key] = True
                        elif new_value_str.lower() == 'false':
                            updated_config[key] = False
                        else:
                            raise ValueError("Boolean value must be 'true' or 'false'.")
                    elif isinstance(original_value_in_config, int):
                        updated_config[key] = int(new_value_str)
                    elif isinstance(original_value_in_config, float):
                        updated_config[key] = float(new_value_str)
                    elif original_value_in_config is None:
                        if new_value_str.lower() in ['none', 'null', '~', '']:
                            updated_config[key] = None
                        else:
                            updated_config[key] = new_value_str
                    else:  # Original was string or unhandled simple type
                        updated_config[key] = new_value_str
                except ValueError as e:
                    messagebox.showerror("Validation Error",
                                         f"Invalid value for '{key}': '{new_value_str}'.\n"
                                         f"Original type: {type(original_value_in_config).__name__}.\nError: {e}")
                    return  # Stop saving
            # else: stored_item is the original complex value, already in updated_config by .copy()

        self.config_data = updated_config
        save_config(CONFIG_FILE, self.config_data)

    def reload_config_ui(self):
        self.config_data = load_config(CONFIG_FILE)
        if self.config_data is None:
            messagebox.showerror("Error", f"Failed to reload '{CONFIG_FILE}'.")
            return
        self.create_widgets()
        messagebox.showinfo("Reloaded", f"Configuration from '{CONFIG_FILE}' has been reloaded.")


def main_gui():
    root = tk.Tk()
    app = ConfigEditorApp(root)
    if app.initialized_properly:
        root.mainloop()


if __name__ == '__main__':
    if not os.path.exists(CONFIG_FILE):
        print(f"'{CONFIG_FILE}' not found. Creating a dummy file for testing purposes matching PARAMETER_OPTIONS.")
        dummy_data = {
            'robot_id': 'MarcoBot-V2',
            'description': 'My Python-powered robot assistant with enhanced config.',
            'operating_frequency_hz': 50,  # Test for numeric Combobox
            'max_torque_nm': 10.5,  # Test for standard Entry (float)
            'calibration_required': False,  # Test for Boolean Radiobutton
            'debug_output_enabled': True,  # Test for Boolean Radiobutton
            'log_level': 'INFO',  # Test for string Combobox
            'robot_mode': 'idle',  # Test for string Combobox
            'motor_pins': {
                'left_fwd': 17, 'left_bwd': 18,
                'right_fwd': 22, 'right_bwd': 23
            },  # Test for complex type (Text view)
            'enabled_sensors': ['ultrasonic_front', 'imu', 'encoder_left'],  # Complex
            'api_endpoint': None,  # Test for standard Entry (None handling)
            'unlisted_option_param': 'some_value'  # Parameter not in PARAMETER_OPTIONS
        }
        try:
            with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
                yaml.dump(dummy_data, f, default_flow_style=False, sort_keys=False)
            print(f"Dummy '{CONFIG_FILE}' created. You can run the script now.")
        except Exception as e:
            print(f"Error creating dummy config file: {e}")

    main_gui()
